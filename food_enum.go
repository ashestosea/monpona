// Code generated by go-enum DO NOT EDIT.
// Version: 0.6.0
// Revision: 919e61c0174b91303753ee3898569a01abb32c97
// Build Date: 2023-12-18T15:54:43Z
// Built By: goreleaser

package main

import (
	"fmt"
	"strings"
)

const (
	// FoodRainbowGrass is a Food of type RainbowGrass.
	FoodRainbowGrass Food = iota
	// FoodOoznip is a Food of type Ooznip.
	FoodOoznip
	// FoodBerry is a Food of type Berry.
	FoodBerry
	// FoodGroundnut is a Food of type Groundnut.
	FoodGroundnut
	// FoodCarnivorous is a Food of type Carnivorous.
	FoodCarnivorous
)

var ErrInvalidFood = fmt.Errorf("not a valid Food, try [%s]", strings.Join(_FoodNames, ", "))

const _FoodName = "RainbowGrassOoznipBerryGroundnutCarnivorous"

var _FoodNames = []string{
	_FoodName[0:12],
	_FoodName[12:18],
	_FoodName[18:23],
	_FoodName[23:32],
	_FoodName[32:43],
}

// FoodNames returns a list of possible string values of Food.
func FoodNames() []string {
	tmp := make([]string, len(_FoodNames))
	copy(tmp, _FoodNames)
	return tmp
}

// FoodValues returns a list of the values for Food
func FoodValues() []Food {
	return []Food{
		FoodRainbowGrass,
		FoodOoznip,
		FoodBerry,
		FoodGroundnut,
		FoodCarnivorous,
	}
}

var _FoodMap = map[Food]string{
	FoodRainbowGrass: _FoodName[0:12],
	FoodOoznip:       _FoodName[12:18],
	FoodBerry:        _FoodName[18:23],
	FoodGroundnut:    _FoodName[23:32],
	FoodCarnivorous:  _FoodName[32:43],
}

// String implements the Stringer interface.
func (x Food) String() string {
	if str, ok := _FoodMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Food(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Food) IsValid() bool {
	_, ok := _FoodMap[x]
	return ok
}

var _FoodValue = map[string]Food{
	_FoodName[0:12]:                   FoodRainbowGrass,
	strings.ToLower(_FoodName[0:12]):  FoodRainbowGrass,
	_FoodName[12:18]:                  FoodOoznip,
	strings.ToLower(_FoodName[12:18]): FoodOoznip,
	_FoodName[18:23]:                  FoodBerry,
	strings.ToLower(_FoodName[18:23]): FoodBerry,
	_FoodName[23:32]:                  FoodGroundnut,
	strings.ToLower(_FoodName[23:32]): FoodGroundnut,
	_FoodName[32:43]:                  FoodCarnivorous,
	strings.ToLower(_FoodName[32:43]): FoodCarnivorous,
}

// ParseFood attempts to convert a string to a Food.
func ParseFood(name string) (Food, error) {
	if x, ok := _FoodValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _FoodValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Food(0), fmt.Errorf("%s is %w", name, ErrInvalidFood)
}

// MarshalText implements the text marshaller method.
func (x Food) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Food) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseFood(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
